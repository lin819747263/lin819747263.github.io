(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{498:function(t,a,s){"use strict";s.r(a);var _=s(3),l=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h4",{attrs:{id:"一、什么是jmm模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是jmm模型"}},[t._v("#")]),t._v(" 一、什么是JMM模型")]),t._v(" "),s("ul",[s("li",[t._v("Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，是一种规范，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。")])]),t._v(" "),s("p",[t._v("模型如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191104195323953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbjgxOTc0NzI2Mw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),t._v(" "),s("p",[s("strong",[t._v("如果线程想要通信的话要执行一下步骤：")])]),t._v(" "),s("ul",[s("li",[t._v("A线程先把本地内存的值写入主内存")]),t._v(" "),s("li",[t._v("B线程从主内存中去读取出A线程写的值")])]),t._v(" "),s("h4",{attrs:{id:"二、jmm模型的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、jmm模型的作用"}},[t._v("#")]),t._v(" 二、JMM模型的作用")]),t._v(" "),s("p",[t._v('由于Java是跨平台语言，在不同操作系统中内存都有一定的差异性，这样久造成了并发不一致，所以JMM的作用就是用来屏蔽掉不同操作系统中的内存差异性来保持并发的一致性。同时JMM也规范了JVM如何与计算机内存进行交互。简单的来说JMM就是Java自己的一套协议来屏蔽掉各种硬件和操作系统的内存访问差异，实现平台一致性达到最终的"一次编写，到处运行"。')]),t._v(" "),s("p",[s("strong",[t._v("上面所说的步骤其实就是实现了线程之间的通信，但是不要以为线程之间的通信就是这么简单的，其实在Java中JMM内存模型定义了八种操作来实现同步的细节。")])]),t._v(" "),s("ul",[s("li",[t._v("read 读取，作用于主内存把变量从主内存中读取到本本地内存。")]),t._v(" "),s("li",[t._v("load 加载，主要作用本地内存，把从主内存中读取的变量加载到本地内存的变量副本中")]),t._v(" "),s("li",[t._v("use 使用，主要作用本地内存，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。、")]),t._v(" "),s("li",[t._v("assign 赋值 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。")]),t._v(" "),s("li",[t._v("store 存储 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。")]),t._v(" "),s("li",[t._v("write 写入 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。")]),t._v(" "),s("li",[t._v("lock 锁定 ：作用于主内存的变量，把一个变量标识为一条线程独占状态。")]),t._v(" "),s("li",[t._v("unlock 解锁：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。")])]),t._v(" "),s("p",[s("strong",[t._v("同时在Java内存模型中明确规定了要执行这些操作需要满足以下规则：")])]),t._v(" "),s("ul",[s("li",[t._v("不允许read和load、store和write的操作单独出现。")]),t._v(" "),s("li",[t._v("不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。")]),t._v(" "),s("li",[t._v("不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。")]),t._v(" "),s("li",[t._v("一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。")]),t._v(" "),s("li",[t._v("一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现\n如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值")]),t._v(" "),s("li",[t._v("如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。\n对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191104202012228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbjgxOTc0NzI2Mw==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})])]),t._v(" "),s("p",[t._v("参考文章：\nhttps://blog.csdn.net/javazejian/article/details/72772461\nhttps://www.cnblogs.com/Scramblecode/p/11392639.html")])])}),[],!1,null,null,null);a.default=l.exports}}]);